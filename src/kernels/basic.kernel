#pragma OPENCL EXTENSION cl_khr_fp64 : enable

typedef struct LinearBVHNodeTag {
  float boundsMin[3];
  float boundsMax[3];

  union {
    int primitivesOffset;
    int secondChildOffset;
  };

  ushort primitiveCount;
  uchar axis;
  uchar pad[1];
} LinearBVHNode;

typedef struct PrimitiveTag {
  float vertexA[3];
  float vertexB[3];
  float vertexC[3];
  float normalA[3];
  float normalB[3];
  float normalC[3];
} Primitive;

typedef struct RayTag {
  float4 origin;
  float4 direction;
} Ray;

typedef struct RayPayloadTag {
  int primitiveIndex;
  int hitType;
  float t;
  float u;
  float v;
} RayPayload;

__global float* getBounds(int dirIsNeg, __global float* boundsMin, __global float* boundsMax) {
  return (dirIsNeg == 0) ? boundsMin : boundsMax;
}

bool intersectTriangle(RayPayload* rayPayload, Ray ray, Primitive primitive) {
  const float EPSILON = 0.0000001;
  float4 vertexA = (float4)(primitive.vertexA[0], primitive.vertexA[1], primitive.vertexA[2], 1);
  float4 vertexB = (float4)(primitive.vertexB[0], primitive.vertexB[1], primitive.vertexB[2], 1);
  float4 vertexC = (float4)(primitive.vertexC[0], primitive.vertexC[1], primitive.vertexC[2], 1);

  float4 v0v1 = vertexB - vertexA;
  float4 v0v2 = vertexC - vertexA;
  float4 pvec = cross(ray.direction, v0v2);
  float det = dot(v0v1, pvec);

  if (fabs(det) < EPSILON) {
    return false;
  }

  float invDet = 1 / det;

  float4 tvec = ray.origin - vertexA;
  float u = dot(tvec,pvec) * invDet;
  if (u < 0 || u > 1) {
    return false;
  }

  float4 qvec = cross(tvec, v0v1);
  float v = dot(ray.direction, qvec) * invDet;
  if (v < 0 || u + v > 1) {
    return false;
  }

  float t = dot(v0v2, qvec) * invDet;

  if (t < rayPayload->t) {
    rayPayload->t = t;
    rayPayload->u = u;
    rayPayload->v = v;

    return true;
  }

  return false;
}

bool intersectBounds(Ray ray, float4 invDir, int dirIsNeg[3], __global float boundsMin[3], __global float boundsMax[3]) {
  float tMin = (getBounds(dirIsNeg[0], boundsMin, boundsMax)[0] - ray.origin.x) * invDir.x;
  float tMax = (getBounds(1 - dirIsNeg[0], boundsMin, boundsMax)[0] - ray.origin.x) * invDir.x;
  float tyMin = (getBounds(dirIsNeg[1], boundsMin, boundsMax)[1] - ray.origin.y) * invDir.y;
  float tyMax = (getBounds(1 - dirIsNeg[1], boundsMin, boundsMax)[1] - ray.origin.y) * invDir.y;

  if (tMin > tyMax || tyMin > tMax) return false;
  if (tyMin > tMin) tMin = tyMin;
  if (tyMax < tMax) tMax = tyMax;

  float tzMin = (getBounds(dirIsNeg[2], boundsMin, boundsMax)[2] - ray.origin.z) * invDir.z;
  float tzMax = (getBounds(1 - dirIsNeg[2], boundsMin, boundsMax)[2] - ray.origin.z) * invDir.z;

  if (tMin > tzMax || tzMin > tMax) return false;
  if (tzMin > tMin) tMin = tzMin;
  if (tzMax < tMax) tMax = tzMax;
  return (tMax > 0);
}

void intersect(RayPayload* rayPayload, Ray ray, __global LinearBVHNode* nodes, __global Primitive* primitives) {
  float4 invDir = (float4)(1.0 / ray.direction.x, 1.0 / ray.direction.y, 1.0 / ray.direction.z, 0);
  int dirIsNeg[3] = {invDir.x < 0, invDir.y < 0, invDir.z < 0};

  int toVisitOffset = 0, currentNodeIndex = 0;
  int nodesToVisit[64];
  while (true) {
    __global const LinearBVHNode* node = &nodes[currentNodeIndex];

    if (intersectBounds(ray, invDir, dirIsNeg, node->boundsMin, node->boundsMax)) {
      if (node->primitiveCount > 0) {
        for (int i = 0; i < node->primitiveCount; i++) {
          if (intersectTriangle(rayPayload, ray, primitives[node->primitivesOffset])) {
            rayPayload->primitiveIndex = node->primitivesOffset;
            rayPayload->hitType = 1;
          }
        }
        if (toVisitOffset == 0) {
          break;
        }
        currentNodeIndex = nodesToVisit[--toVisitOffset];
      }
      else {
        if (dirIsNeg[node->axis]) {
          nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
          currentNodeIndex = node->secondChildOffset;
        } else {
          nodesToVisit[toVisitOffset++] = node->secondChildOffset;
          currentNodeIndex = currentNodeIndex + 1;
        }
      }
    }
    else {
      if (toVisitOffset == 0) {
        break;
      }
      currentNodeIndex = nodesToVisit[--toVisitOffset];
    }
  }
}

__kernel void linearKernel(__global LinearBVHNode* linearNodes, __global Primitive* primitives, __global float* output, uint currentBlock, uint width, uint height, uint depth) {
  int blockIDY = get_global_id(1) + ((currentBlock / (width / get_global_size(0))) * get_global_size(1));
  int blockIDX = get_global_id(0) + ((currentBlock % (width / get_global_size(0))) * get_global_size(0));
  int blockID = (blockIDY * width + blockIDX) * depth;

  if (blockIDX >= width || blockIDY >= height) {
    return;
  }

  float3 outputColor = (float3)(0, 0, 0);

  float4 cameraPosition = (float4)(0, 2.5, -50, 1);
  float4 filmPosition = (float4)(((float)blockIDX / width) - 0.5f, ((float)blockIDY / height) - 0.5f, 0, 1);
  float4 aperaturePosition = (float4)(0.0, 0.0, 5, 1);

  RayPayload rayPayload = {0, 0, FLT_MAX, 0, 0};

  Ray ray = {
    .origin = cameraPosition + filmPosition,
    .direction = aperaturePosition - filmPosition
  };

  intersect(&rayPayload, ray, linearNodes, primitives);

  if (rayPayload.hitType == 1) {
    float3 barycentrics = (float3)(1.0 - rayPayload.u - rayPayload.v, rayPayload.u, rayPayload.v);
    float3 normalA = (float3)(primitives[rayPayload.primitiveIndex].normalA[0], primitives[rayPayload.primitiveIndex].normalA[1], primitives[rayPayload.primitiveIndex].normalA[2]);
    float3 normalB = (float3)(primitives[rayPayload.primitiveIndex].normalB[0], primitives[rayPayload.primitiveIndex].normalB[1], primitives[rayPayload.primitiveIndex].normalB[2]);
    float3 normalC = (float3)(primitives[rayPayload.primitiveIndex].normalC[0], primitives[rayPayload.primitiveIndex].normalC[1], primitives[rayPayload.primitiveIndex].normalC[2]);

    float3 normal = fabs(normalize(normalA * barycentrics.x + normalB * barycentrics.y + normalC * barycentrics.z));

    outputColor = (float3)(normal.x * 255, normal.y * 255, normal.z * 255);
    // outputColor = (float3)(barycentrics.x * 255, barycentrics.y * 255, barycentrics.z * 255);
  }

  output[blockID + 0] = outputColor.x;
  output[blockID + 1] = outputColor.y;
  output[blockID + 2] = outputColor.z;
}

__kernel void tileKernel(__global LinearBVHNode* linearNodes, __global Primitive* primitives, __global float* output, uint currentBlock, uint width, uint height, uint depth) {
  int localBlockID = get_group_id(1) * get_num_groups(0) + get_group_id(0);
  int localIDY = get_local_id(1) + ((localBlockID / (get_global_size(0) / get_local_size(0))) * get_local_size(1));
  int localIDX = get_local_id(0) + ((localBlockID % (get_global_size(0) / get_local_size(0))) * get_local_size(0));
  int blockIDY = localIDY + ((currentBlock / (width / get_global_size(0))) * get_global_size(1));
  int blockIDX = localIDX + ((currentBlock % (width / get_global_size(0))) * get_global_size(0));
  int blockID = (blockIDY * width + blockIDX) * depth;

  if (blockIDX >= width || blockIDY >= height) {
    return;
  }

  float3 outputColor = (float3)(0, 0, 0);

  float4 cameraPosition = (float4)(0, 2.5, -50, 1);
  float4 filmPosition = (float4)(((float)blockIDX / width) - 0.5f, ((float)blockIDY / height) - 0.5f, 0, 1);
  float4 aperaturePosition = (float4)(0.0, 0.0, 5, 1);

  RayPayload rayPayload = {0, 0, FLT_MAX, 0, 0};

  Ray ray = {
    .origin = cameraPosition + filmPosition,
    .direction = aperaturePosition - filmPosition
  };

  intersect(&rayPayload, ray, linearNodes, primitives);

  if (rayPayload.hitType == 1) {
    float3 barycentrics = (float3)(1.0 - rayPayload.u - rayPayload.v, rayPayload.u, rayPayload.v);
    float3 normalA = (float3)(primitives[rayPayload.primitiveIndex].normalA[0], primitives[rayPayload.primitiveIndex].normalA[1], primitives[rayPayload.primitiveIndex].normalA[2]);
    float3 normalB = (float3)(primitives[rayPayload.primitiveIndex].normalB[0], primitives[rayPayload.primitiveIndex].normalB[1], primitives[rayPayload.primitiveIndex].normalB[2]);
    float3 normalC = (float3)(primitives[rayPayload.primitiveIndex].normalC[0], primitives[rayPayload.primitiveIndex].normalC[1], primitives[rayPayload.primitiveIndex].normalC[2]);

    float3 normal = fabs(normalize(normalA * barycentrics.x + normalB * barycentrics.y + normalC * barycentrics.z));

    // outputColor = (float3)(normal.x * 255, normal.y * 255, normal.z * 255);
    outputColor = (float3)(barycentrics.x * 255, barycentrics.y * 255, barycentrics.z * 255);
  }

  output[blockID + 0] = outputColor.x;
  output[blockID + 1] = outputColor.y;
  output[blockID + 2] = outputColor.z;
}